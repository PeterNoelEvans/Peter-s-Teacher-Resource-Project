<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Take Assessment</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.3/font/bootstrap-icons.css">
    <style>
        .quiz-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            padding: 30px;
            margin-bottom: 30px;
        }
        .matching-item, .list-group-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 5px;
            min-height: 60px;
        }
        .matching-item:hover {
            background-color: #f8f9fa;
        }
        .matching-expression {
            font-weight: 500;
            min-width: 200px;
            padding-right: 20px;
        }
        .question-title {
            background-color: #f0f8ff;
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        .question-text {
            font-size: 1.1rem;
            margin-bottom: 20px;
            padding: 0 10px;
        }
        .question-instructions {
            font-style: italic;
            color: #6c757d;
            margin-bottom: 20px;
        }
        .nav-pills .nav-link.active {
            background-color: #0d6efd;
        }
        .nav-pills .nav-link {
            color: #212529;
        }
        .quiz-footer {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
        }
        .multiple-choice-option {
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .multiple-choice-option:hover {
            background-color: #f8f9fa;
        }
        .multiple-choice-option.selected {
            background-color: #e7f3ff;
            border-color: #0d6efd;
        }
        .list-group {
            margin-bottom: 0;
        }
        .list-group-item {
            margin-bottom: 15px !important;
            height: auto;
            min-height: 54px;
            display: flex;
            align-items: center;
        }
        .input-group {
            margin-bottom: 15px !important;
            height: auto;
        }
        .form-select {
            height: 54px;
        }
        .list-group-item:last-child {
            margin-bottom: 15px !important;
        }
        /* Drag and drop styles */
        .draggable-items-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
        .draggable-item {
            padding: 8px 12px;
            background-color: #e7f3ff;
            border: 1px solid #b8daff;
            border-radius: 4px;
            cursor: grab;
            user-select: none;
            transition: all 0.2s;
        }
        .draggable-item:hover {
            background-color: #d0e7ff;
        }
        .draggable-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        .drop-target {
            display: inline-block !important;
            width: 120px !important;
            height: 35px !important;
            border: 2px dashed #ced4da !important;
            border-radius: 4px !important;
            margin: 0 5px !important;
            vertical-align: middle !important;
            background-color: #f8f9fa !important;
            transition: all 0.2s;
        }
        .drop-target.highlight {
            border-color: #0d6efd !important;
            background-color: #e7f3ff !important;
        }
        .drop-target.filled {
            border-style: solid !important;
            border-color: #6c757d !important;
            background-color: #e9ecef !important;
            text-align: center !important;
            line-height: 35px !important;
            padding: 0 5px !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            white-space: nowrap !important;
            font-weight: 500 !important;
        }
        .drop-target.correct {
            border-color: #28a745 !important;
            background-color: #d4edda !important;
        }
        .drop-target.incorrect {
            border-color: #dc3545 !important;
            background-color: #f8d7da !important;
        }
        .sentence-container {
            line-height: 2.5 !important;
            margin-bottom: 15px !important;
            font-size: 1.1rem !important;
        }
        
        /* New styles for paragraph container */
        .paragraph-container {
            background-color: #fff;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .paragraph-container .sentence-container {
            font-size: 1.25rem !important;
            line-height: 2.2 !important;
        }
        
        /* Long paragraph specific styles to fix formatting */
        .long-paragraph-container {
            margin-top: 20px;
        }
        
        /* Fix the actual drop zones */
        [id^="target-"] {
            display: inline-block !important;
            min-width: 120px !important;
            height: 35px !important;
            border: 2px dashed #ced4da !important;
            border-radius: 4px !important;
            margin: 0 5px !important;
            vertical-align: middle !important;
            background-color: #f8f9fa !important;
        }
        
        /* Word bank items */
        #dragDropContainer .draggable-item {
            display: inline-block;
            padding: 8px 12px;
            margin: 5px;
            background-color: #e7f3ff;
            border: 1px solid #b8daff;
            border-radius: 4px;
            cursor: grab;
        }
        
        /* Image matching styles */
        .images-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .image-item {
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            text-align: center;
            position: relative;
        }
        .image-item img {
            max-width: 100%;
            height: 180px;
            object-fit: cover;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        .image-drop-target {
            min-height: 40px;
            border: 2px dashed #ced4da;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
            transition: all 0.2s;
            background-color: #f8f9fa;
        }
        .image-drop-target.highlight {
            border-color: #0d6efd;
            background-color: #e7f3ff;
        }
        .image-drop-target.filled {
            border-style: solid;
            border-color: #6c757d;
            background-color: #e9ecef;
            padding: 5px;
        }
        .image-drop-target.correct {
            border-color: #28a745;
            background-color: #d4edda;
        }
        .image-drop-target.incorrect {
            border-color: #dc3545;
            background-color: #f8d7da;
        }
        .recording-indicator {
            color: #d32f2f;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .recording-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #d32f2f;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.6); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Image Fill Blank Styles */
        .card-img-top {
            background-color: #f8f9fa;
            padding: 1rem;
            text-align: center;
        }
        
        .card-img-top img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }
        
        .sentence-container {
            font-size: 1.1rem;
            line-height: 1.6;
            margin: 1rem 0;
        }
        
        .drop-target {
            display: inline-block;
            min-width: 100px;
            height: 30px;
            border: 2px dashed #ccc;
            border-radius: 4px;
            margin: 0 5px;
            vertical-align: middle;
            background-color: #f8f9fa;
        }
        
        .drop-target.dragover {
            border-color: #007bff;
            background-color: #e9ecef;
        }
        
        .drop-target.filled {
            border-style: solid;
            border-color: #28a745;
            background-color: #fff;
        }
        
        .drop-target.incorrect {
            border-color: #dc3545;
            background-color: #fff;
        }
        
        .draggable-items-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        
        .draggable-item {
            padding: 0.5rem 1rem;
            background-color: #fff;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: move;
            user-select: none;
        }
        
        .draggable-item:hover {
            background-color: #e9ecef;
        }
        
        .draggable-item.dragging {
            opacity: 0.5;
        }
        
        .recording-dot.pulsing {
            animation: pulse 1s infinite;
        }
        
        /* Matching assessment styles */
        .matching-row {
            margin-bottom: 1rem;
        }
        
        .matching-row .card {
            border: 1px solid #dee2e6;
            border-radius: 6px;
        }
        
        .matching-row select.is-valid,
        .matching-row select.is-invalid {
            padding-right: calc(1.5em + .75rem);
            background-position: right calc(.375em + .1875rem) center;
            background-size: calc(.75em + .375rem) calc(.75em + .375rem);
        }
        
        .matching-row select.is-valid {
            border-color: #28a745;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath fill='%2328a745' d='M2.3 6.73L.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1z'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
        }
        
        .matching-row select.is-invalid {
            border-color: #dc3545;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
        }
    </style>
</head>
<body class="bg-light">
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="/student/dashboard">Student Portal</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="/student/dashboard">Dashboard</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/student/resources">Resources</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/student/assessments">Assessments</a>
                    </li>
                </ul>
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <button class="btn btn-outline-light" onclick="logout()">Logout</button>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <!-- Debug information - hidden by default, visible with ?debug=true parameter -->
        <div class="alert alert-info mb-3" id="debugInfo" style="font-family: monospace; font-size: 13px; display: none;">
            Loading debug info...
        </div>
        
        <!-- Debug buttons only shown when debug=true -->
        <div id="debugButtons" style="display: none;" class="mb-3">
            <button id="refreshPage" class="btn btn-sm btn-secondary">Refresh Page</button>
        </div>
        
        <div id="loader" class="text-center my-4 d-none">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p>Loading assessment...</p>
        </div>
        
        <!-- Add debugging info -->
        <div class="mb-3 text-muted small">
            <p id="debugAssessmentId">Assessment ID: Loading...</p>
        </div>
        
        <div id="assessmentContainer" style="display: none;">
            <!-- Assessment content will be loaded here -->
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const token = localStorage.getItem('token');
        let assessment = null;
        let answers = [];
        let currentQuestionIndex = 0;
        let attemptCount = 0;
        let submissionData = [];
        let startTime = null;
        let assessmentId = null;
        
        // Global userAnswers object to store all answers
        window.userAnswers = [];
        
        // Allow drop on drop targets
        function allowDrop(event) {
            event.preventDefault();
        }
        
        // Handle drag event
        function drag(event) {
            event.dataTransfer.setData("text", event.target.id);
            event.target.classList.add('dragging');
        }
        
        // Handle drop event
        function drop(event) {
            event.preventDefault();
            const data = event.dataTransfer.getData("text");
            const draggedItem = document.getElementById(data);
            
            if (draggedItem && event.target.classList.contains('drop-target')) {
                // Clear any existing content
                event.target.innerHTML = '';
                // Add the dragged text to the drop target
                event.target.textContent = draggedItem.textContent;
                
                // Update styling for the filled drop target
                event.target.classList.add('filled');
                event.target.style.border = '2px solid #6c757d';
                event.target.style.backgroundColor = '#e9ecef';
                event.target.style.color = '#212529';
                event.target.style.padding = '5px 10px';
                event.target.style.textAlign = 'center';
                event.target.style.fontWeight = '500';
                
                // Hide the original draggable item
                draggedItem.style.display = 'none';
                
                // Update the corresponding hidden inputs
                const index = event.target.dataset.index;
                const questionId = assessment.questions && assessment.questions.length > 0 ? assessment.questions[0].id : Date.now();
                
                // Find and update hidden input fields but make sure they don't have 'required' attribute
                const meaningInput = document.querySelector(`input[name="meaning_question_${questionId}_${index}"]`);
                if (meaningInput) {
                    meaningInput.value = draggedItem.textContent;
                    meaningInput.removeAttribute('required');
                }
                
                // Store the answer in userAnswers
                if (!window.userAnswers[0]) window.userAnswers[0] = {};
                if (!window.userAnswers[0].dropTargets) window.userAnswers[0].dropTargets = {};
                window.userAnswers[0].dropTargets[index] = {
                    text: draggedItem.textContent,
                    correct: draggedItem.textContent === event.target.dataset.correctAnswer
                };
            }
        }
        
        // Simple debug utility
        function showDebugInfo() {
            const urlParams = new URLSearchParams(window.location.search);
            const debug = urlParams.get('debug');
            if (debug === 'true') {
                const debugDiv = document.getElementById('debugInfo');
                debugDiv.style.display = 'block';
                
                // Also show debug buttons
                const debugButtons = document.getElementById('debugButtons');
                if (debugButtons) {
                    debugButtons.style.display = 'block';
                    
                    // Add event listener for refresh button
                    const refreshButton = document.getElementById('refreshPage');
                    if (refreshButton) {
                        refreshButton.addEventListener('click', function() {
                            location.reload();
                        });
                    }
                }
                
                assessmentId = urlParams.get('id');
                debugDiv.innerHTML = `
                    <strong>Debug Information:</strong><br>
                    URL ID Parameter: ${assessmentId || 'None'}<br>
                    Current URL: ${window.location.href}<br>
                `;
                
                // Listen for assessment load event to update with more info
                document.addEventListener('assessment-loaded', (e) => {
                    const assessment = e.detail;
                    debugDiv.innerHTML += `<br>
                        <strong>Loaded Assessment:</strong><br>
                        Loaded Assessment ID: ${assessment.id}<br>
                        Title: ${assessment.title}<br>
                        Type: ${assessment.type}
                    `;
                });
            }
        }
        
        // Call showDebugInfo immediately
        showDebugInfo();
        
        // Check authentication
        if (!token) {
            window.location.href = '/login';
        }
        
        document.addEventListener('DOMContentLoaded', loadAssessment);
        
        // Function to load the assessment data
        async function loadAssessment() {
            try {
                showLoader();
                
                // Fetch assessment data
                const urlParams = new URLSearchParams(window.location.search);
                const assessmentId = urlParams.get('id');
                
                // Update debug info with URL parameters
                document.getElementById('debugInfo').innerHTML = `
                    URL ID Parameter: ${assessmentId || 'None'}<br>
                    Current URL: ${window.location.href}
                `;
                
                const response = await fetch(`/api/assessments/${assessmentId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                const data = await response.json();
                if (!response.ok) throw new Error('Failed to load assessment');
                assessment = data;
                // Make assessment data globally available for the emergency fix
                window.assessment = assessment;
                console.log('[DEBUG] Assessment loaded:', assessment);
                
                // Add detailed API response debugging
                console.log('[API DEBUG] ==================== API RESPONSE START ====================');
                console.log('[API DEBUG] Raw assessment object:', JSON.stringify(assessment));
                console.log('[API DEBUG] First level keys:', Object.keys(assessment));
                if (assessment.questions && assessment.questions.length > 0) {
                    console.log('[API DEBUG] First question:', JSON.stringify(assessment.questions[0]));
                    console.log('[API DEBUG] Question keys:', Object.keys(assessment.questions[0]));
                }
                console.log('[API DEBUG] ==================== API RESPONSE END ====================');
                
                // Create containers IMMEDIATELY after assessment data is loaded to ensure they exist
                const container = document.getElementById('assessmentContainer');
                container.style.display = 'block';
                
                // If this is a drag-and-drop assessment, immediately create the containers
                // This ensures they exist before any emergency fix scripts try to access them
                if (assessment.type === 'drag-and-drop') {
                    console.log('Creating drag-and-drop containers early');
                    
                    // Only create a container placeholder without duplicating titles and descriptions
                    // We will fill it properly in renderAssessment
                    container.innerHTML = `
                        <div id="dragDropAssessmentCard">
                            <!-- Assessment card will be rendered here -->
                            <div class="text-center">
                                <div class="spinner-border text-primary" role="status"></div>
                                <p>Loading assessment...</p>
                            </div>
                        </div>
                    `;
                    
                    // Dispatch an event for the emergency fix script to detect
                    setTimeout(() => {
                        document.dispatchEvent(new CustomEvent('assessment-loaded', {
                            detail: assessment
                        }));
                    }, 100);
                } else {
                    // For non-drag-drop, dispatch the event immediately
                    document.dispatchEvent(new CustomEvent('assessment-loaded', {
                        detail: assessment
                    }));
                }
                
                // Update debug info with assessment details
                document.getElementById('debugInfo').innerHTML += `<br><br>
                    Loaded Assessment ID: ${assessment.id}<br>
                    Title: ${assessment.title}<br>
                    Type: ${assessment.type}
                `;
                
                if (assessment) {
                    // Display the assessment ID for debugging
                    document.getElementById('debugAssessmentId').textContent = `Assessment ID: ${assessmentId}`;
                    
                    if (!assessmentId) {
                        showError('No assessment ID provided');
                        return;
                    }
                    
                    // Load submission data to check attempts
                    await fetchSubmissionData();
                    
                    // Check if user has reached max attempts
                    if (assessment.maxAttempts && submissionData.length >= assessment.maxAttempts) {
                        showMaxAttemptsReached();
                        return;
                    }
                    
                    // Don't call renderAssessment immediately for drag-and-drop type
                    // Instead wait a moment to ensure containers are in the DOM
                    if (assessment.type === 'drag-and-drop') {
                        setTimeout(renderAssessment, 300); // Delay to ensure containers are ready
                    } else {
                        renderAssessment();
                    }
                }
            } catch (error) {
                console.error('Error loading assessment:', error);
                showError(`Error loading assessment: ${error.message}`);
            } finally {
                hideLoader();
            }
        }
        
        // Add the missing fetchSubmissionData function
        async function fetchSubmissionData() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const assessmentId = urlParams.get('id');
                
                if (!assessmentId) return;
                
                const response = await fetch(`/api/assessments/${assessmentId}/submissions`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (response.ok) {
                    submissionData = await response.json();
                    if (Array.isArray(submissionData) && submissionData.length > 0) {
                        attemptCount = submissionData.length;
                    }
                    console.log('Submission data loaded:', submissionData);
                }
            } catch (error) {
                console.error('Error loading submission data:', error);
                // Continue without submission data
                submissionData = [];
                attemptCount = 0;
            }
        }
        
        // Function to render the assessment
        function renderAssessment() {
            // Get container and ensure it's visible
            const container = document.getElementById('assessmentContainer');
            container.style.display = 'block';
            
            // Set up attempts information
            let attemptsHtml = '';
            if (assessment.maxAttempts) {
                attemptsHtml = `<div id="attemptsInfo" class="mb-2"><strong>Attempts:</strong> <span id="attemptCount">${attemptCount}</span> / ${assessment.maxAttempts}</div>`;
                maxAttempts = assessment.maxAttempts;
            } else {
                attemptsHtml = `<div id="attemptsInfo" class="mb-2"><strong>Attempts:</strong> <span id="attemptCount">${attemptCount}</span> / Unlimited</div>`;
                maxAttempts = null;
            }
            
            // Function to convert newlines to <br> tags
            const formatWithLineBreaks = (text) => {
                return text ? text.replace(/\\n/g, '<br>').replace(/\n/g, '<br>') : '';
            };
            
            try {
                // Determine assessment type and render accordingly
                switch(assessment.type) {
                    case 'multiple-choice':
                        renderMultipleChoiceAssessment();
                        break;
                        
                    case 'matching':
                        // Handle matching type assessments
                        container.innerHTML = `
                            <div class="card mb-4">
                                <div class="card-header bg-primary text-white">
                                    <h3 class="mb-0" id="assessmentTitle">${assessment.title || 'Vocabulary'}</h3>
                                </div>
                                <div class="card-body">
                                    <p class="mb-3" id="assessmentDescription">${formatWithLineBreaks(assessment.description || 'Match the following items.')}</p>
                                    
                                    ${assessment.criteria ? `
                                        <div class="alert alert-info mb-3">
                                            <strong>Criteria:</strong> ${formatWithLineBreaks(assessment.criteria)}
                                        </div>
                                    ` : ''}
                                    ${attemptsHtml}
                                    <div id="matchingContainer" class="mb-4">
                                        <div class="text-center my-3">
                                            <div class="spinner-border text-primary" role="status">
                                                <span class="visually-hidden">Loading...</span>
                                            </div>
                                            <p>Loading matching items...</p>
                                        </div>
                                    </div>
                                    
                                    <div class="mt-3">
                                        <button id="checkMatchingBtn" class="btn btn-primary">Check Answers</button>
                                        <button id="submitMatchingBtn" class="btn btn-success ms-2">Submit</button>
                                    </div>
                                </div>
                            </div>
                        `;
                        
                        // Set up matching functionality
                        setupMatchingAssessment();
                        break;
                        
                    case 'drag-and-drop':
                        // For drag-and-drop, we need to ensure the container exists and is properly set up
                        const dragDropCard = document.getElementById('dragDropAssessmentCard');
                        
                        // Replace the placeholder with the properly structured card
                        if (dragDropCard) {
                            dragDropCard.innerHTML = `
                                <div class="card mb-4">
                                    <div class="card-header bg-primary text-white">
                                        <h3 class="mb-0" id="assessmentTitle">${assessment.title || 'Drag and Drop Exercise'}</h3>
                                    </div>
                                    <div class="card-body">
                                        <p class="mb-3" id="assessmentDescription">${formatWithLineBreaks(assessment.description || 'Complete the drag and drop exercise below.')}</p>
                                        ${attemptsHtml}
                                        <div id="dragDropContainerWrapper" class="mt-4">
                                            <div id="dragDropContainer" class="mt-4">
                                                <div class="text-center">
                                                    <div class="spinner-border text-primary" role="status"></div>
                                                    <p>Preparing drag and drop exercise...</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;
                            
                            // Get the container we just created
                            const ddContainer = document.getElementById('dragDropContainer');
                            if (ddContainer) {
                                console.log('Rendering drag-and-drop assessment:', assessment);
                                // Add debug info to UI if debug parameter is present
                                const urlParams = new URLSearchParams(window.location.search);
                                if (urlParams.get('debug') === 'true') {
                                    ddContainer.innerHTML = `
                                        <div class="alert alert-info mb-3">
                                            <strong>Assessment Debug:</strong><br>
                                            ID: ${assessment.id}<br>
                                            Type: ${assessment.type}<br>
                                            Subtype: ${assessment.subtype || 'Not specified'}<br>
                                            Questions: ${assessment.questions ? assessment.questions.length : 0}<br>
                                            Word Bank: ${JSON.stringify(assessment.wordBank || 
                                                (assessment.questions && assessment.questions[0] && assessment.questions[0].wordBank) || [])}
                                        </div>
                                    `;
                                }
                                renderDragAndDropAssessment(ddContainer);
                                
                                // Also trigger the emergency fix one more time
                                if (typeof window.attemptFix === 'function') {
                                    setTimeout(window.attemptFix, 200);
                                }
                            } else {
                                console.error('Failed to find or create drag-and-drop container');
                            }
                        } else {
                            // If for some reason we don't have the placeholder, create everything from scratch
                            console.log('Drag-drop card placeholder not found, creating full structure');
                            container.innerHTML = `
                                <div class="card mb-4">
                                    <div class="card-header bg-primary text-white">
                                        <h3 class="mb-0" id="assessmentTitle">${assessment.title || 'Drag and Drop Exercise'}</h3>
                                    </div>
                                    <div class="card-body">
                                        <p class="mb-3" id="assessmentDescription">${formatWithLineBreaks(assessment.description || 'Complete the drag and drop exercise below.')}</p>
                                        ${attemptsHtml}
                                        <div id="dragDropContainerWrapper" class="mt-4">
                                            <div id="dragDropContainer" class="mt-4">
                                                <div class="text-center">
                                                    <div class="spinner-border text-primary" role="status"></div>
                                                    <p>Preparing drag and drop exercise...</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;
                            
                            const ddContainer = document.getElementById('dragDropContainer');
                            if (ddContainer) {
                                renderDragAndDropAssessment(ddContainer);
                            }
                        }
                        break;
                        
                    case 'speaking':
                        // Handle speaking assessments specifically
                        container.innerHTML = `
                            <div class="card mb-4">
                                <div class="card-header bg-primary text-white">
                                    <h3 class="mb-0" id="assessmentTitle">${assessment.title || 'Speaking Assessment'}</h3>
                                </div>
                                <div class="card-body">
                                    <p class="mb-3" id="assessmentDescription">${formatWithLineBreaks(assessment.description || 'Record your response to the speaking prompt.')}</p>
                                    
                                    ${assessment.criteria ? `
                                        <div class="alert alert-info mb-3">
                                            <strong>Criteria:</strong> ${formatWithLineBreaks(assessment.criteria)}
                                        </div>
                                    ` : ''}
                                    ${attemptsHtml}
                                    <div class="mb-4">
                                        <h4>Recording</h4>
                                        <div class="d-flex gap-2 mb-3">
                                            <button id="startRecordingBtn" class="btn btn-primary">
                                                <i class="bi bi-mic-fill"></i> Start Recording
                                            </button>
                                            <button id="stopRecordingBtn" class="btn btn-danger" style="display: none;">
                                                <i class="bi bi-stop-fill"></i> Stop Recording
                                            </button>
                                        </div>
                                        <div id="recordingStatus" class="text-muted mb-2"></div>
                                        <div id="recordingTimer" class="text-muted mb-3" style="display: none;">00:00</div>
                                        
                                        <div id="audioPreview" class="mb-3" style="display: none;">
                                            <h5>Recording Preview</h5>
                                            <audio id="audioPlayer" controls class="w-100"></audio>
                                        </div>
                                
                                        <button id="submitRecordingBtn" class="btn btn-success mt-3" style="display: none;">
                                            <i class="bi bi-check-circle"></i> Submit Recording
                                        </button>
                                    </div>
                                </div>
                            </div>
                        `;
                        
                        // Set up recording functionality
                        setupRecording();
                        break;
                        
                    case 'writing':
                    case 'writing-long':
                        container.innerHTML = `
                            <div class="card mb-4">
                                <div class="card-header bg-primary text-white">
                                    <h3 class="mb-0" id="assessmentTitle">${assessment.title || 'Writing Assignment'}</h3>
                                </div>
                                <div class="card-body">
                                    <p class="mb-3" id="assessmentDescription">${formatWithLineBreaks(assessment.description || '')}</p>
                                    ${assessment.criteria ? `
                                        <div class="card mb-4">
                                            <div class="card-header">
                                                <h5 class="mb-0">Grading Criteria</h5>
                                            </div>
                                            <div class="card-body">
                                                <p class="mb-0">${assessment.criteria}</p>
                                            </div>
                                        </div>
                                    ` : ''}
                                    ${attemptsHtml}
                                    <div class="writing-assignment-container"></div>
                                </div>
                            </div>
                        `;
                        renderWritingAssessment();
                        break;
                        
                    default:
                        container.innerHTML = `
                            <div class="card mb-4">
                                <div class="card-header bg-primary text-white">
                                    <h3 class="mb-0" id="assessmentTitle">${assessment.title || 'Assessment'}</h3>
                                </div>
                                <div class="card-body">
                                    <p class="mb-3" id="assessmentDescription">${formatWithLineBreaks(assessment.description || '')}</p>
                                    <div class="alert alert-warning">
                                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                                        Unsupported assessment type: ${assessment.type}
                                    </div>
                                </div>
                            </div>
                        `;
                        break;
                }
            } catch (error) {
                console.error('Error rendering assessment:', error);
                container.innerHTML = `
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        Error rendering assessment: ${error.message}
                    </div>
                `;
            }
        }
        
        function shuffleArray(array) {
            // Create a copy to avoid modifying the original
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        function logout() {
            localStorage.removeItem('token');
            window.location.href = '/login';
        }
        
        function renderMultipleChoiceQuestion(question, questionDiv) {
            // Support both 'options' and 'choices' keys
            const choices = question.options || question.choices || [];
            // Create container for options
            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'options-container';
            // Add each option
            choices.forEach((option, optionIndex) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'multiple-choice-option';
                optionDiv.textContent = option;
                optionDiv.dataset.optionIndex = optionIndex;
                // Check if this option is already selected
                if (userAnswers[currentQuestionIndex] && 
                    userAnswers[currentQuestionIndex].selectedOption === optionIndex) {
                    optionDiv.classList.add('selected');
                }
                // Add click handler
                optionDiv.addEventListener('click', function() {
                    // Remove selected class from all options
                    optionsContainer.querySelectorAll('.multiple-choice-option').forEach(el => {
                        el.classList.remove('selected');
                    });
                    // Add selected class to this option
                    this.classList.add('selected');
                    // Save the answer
                    updateMultipleChoiceAnswer(optionIndex);
                });
                optionsContainer.appendChild(optionDiv);
            });
            questionDiv.appendChild(optionsContainer);
        }
        
        function updateMultipleChoiceAnswer(optionIndex) {
            // Initialize if not exists
            if (!userAnswers[currentQuestionIndex]) {
                userAnswers[currentQuestionIndex] = {};
            }
            
            // Save the selected option
            userAnswers[currentQuestionIndex].selectedOption = optionIndex;
            console.log('Updated answer:', userAnswers);
        }
        
        function renderDragAndDropQuestion(question, questionDiv) {
            // Support subtype: fill-in-blank, image-fill-blank, long-paragraph-fill-in-blank
            if (
                question.subtype === 'fill-in-blank' || question.subtype === 'image-fill-blank' || question.subtype === 'long-paragraph-fill-in-blank' ||
                (assessment.subtype === 'fill-in-blank') || (assessment.subtype === 'image-fill-blank') || (assessment.subtype === 'long-paragraph-fill-in-blank')
            ) {
                // Add instructions
                const instructionsDiv = document.createElement('div');
                instructionsDiv.className = 'question-instructions';
                instructionsDiv.textContent = question.instructions || 'Drag the correct word from the word bank into each blank.';
                questionDiv.appendChild(instructionsDiv);

                // Word bank
                const wordBank = document.createElement('div');
                wordBank.className = 'draggable-items-container';
                // Use question.words for the word bank
                const words = question.words || question.wordBank || question.options || [];
                const shuffledWords = [...words].sort(() => Math.random() - 0.5);
                shuffledWords.forEach(word => {
                    const draggableItem = document.createElement('div');
                    draggableItem.className = 'draggable-item';
                    draggableItem.textContent = word;
                    draggableItem.setAttribute('draggable', 'true');
                    draggableItem.dataset.value = word;
                    draggableItem.addEventListener('dragstart', handleDragStart);
                    draggableItem.addEventListener('dragend', handleDragEnd);
                    wordBank.appendChild(draggableItem);
                });
                questionDiv.appendChild(wordBank);

                // Sentences with blanks
                const sentencesContainer = document.createElement('div');
                sentencesContainer.className = 'sentences-container';
                (question.sentences || []).forEach((sentence, idx) => {
                    // Create a card for each sentence
                    const sentenceCard = document.createElement('div');
                    sentenceCard.className = 'card mb-4';
                    
                    // If this is image-fill-blank, add the image
                    if (question.subtype === 'image-fill-blank' || assessment.subtype === 'image-fill-blank') {
                        const imageDiv = document.createElement('div');
                        imageDiv.className = 'card-img-top';
                        const img = document.createElement('img');
                        img.src = sentence.image;
                        img.alt = `Image for sentence ${idx + 1}`;
                        img.className = 'img-fluid';
                        img.style.maxHeight = '200px';
                        img.style.objectFit = 'contain';
                        imageDiv.appendChild(img);
                        sentenceCard.appendChild(imageDiv);
                    }

                    const cardBody = document.createElement('div');
                    cardBody.className = 'card-body';
                    
                    const sentenceDiv = document.createElement('div');
                    sentenceDiv.className = 'sentence-container';
                    // Replace \n with <br> for line breaks
                    let sentenceText = sentence.text.replace(/\\n/g, '\n');
                    const parts = sentenceText.split(/___|\[BLANK\]/);
                    for (let i = 0; i < parts.length; i++) {
                        // Add the text part (with line breaks)
                        const textParts = parts[i].split('\n');
                        textParts.forEach((t, j) => {
                            if (t) sentenceDiv.appendChild(document.createTextNode(t));
                            if (j < textParts.length - 1) sentenceDiv.appendChild(document.createElement('br'));
                        });
                        if (i < parts.length - 1) {
                            const dropTarget = document.createElement('div');
                            dropTarget.className = 'drop-target';
                            dropTarget.dataset.sentenceIndex = idx;
                            dropTarget.dataset.blankIndex = i;
                            dropTarget.dataset.correctAnswer = sentence.answers ? sentence.answers[i] : sentence.answer;
                            dropTarget.addEventListener('dragover', handleDragOver);
                            dropTarget.addEventListener('dragenter', handleDragEnter);
                            dropTarget.addEventListener('dragleave', handleDragLeave);
                            dropTarget.addEventListener('drop', handleDrop);
                            sentenceDiv.appendChild(dropTarget);
                        }
                    }
                    cardBody.appendChild(sentenceDiv);
                    sentenceCard.appendChild(cardBody);
                    sentencesContainer.appendChild(sentenceCard);
                });
                questionDiv.appendChild(sentencesContainer);

                // Add a check answers button
                const checkButton = document.createElement('button');
                checkButton.className = 'btn btn-primary mt-3';
                checkButton.textContent = 'Check Answers';
                checkButton.addEventListener('click', () => checkDragDropAnswers(questionDiv));
                questionDiv.appendChild(checkButton);
                return;
            }
            // ... fallback to original drag-and-drop (sequence) ...
            // Add instructions
            const instructionsDiv = document.createElement('div');
            instructionsDiv.className = 'question-instructions';
            instructionsDiv.textContent = 'Drag the words into the correct positions in the sentences.';
            questionDiv.appendChild(instructionsDiv);
            
            // Create container for draggable items
            const draggableContainer = document.createElement('div');
            draggableContainer.className = 'draggable-items-container';
            
            // Get all the options (words to drag)
            const options = question.options || [];
            
            // Shuffle the options to display them in random order
            const shuffledOptions = [...options].sort(() => Math.random() - 0.5);
            
            // Create draggable items
            shuffledOptions.forEach(option => {
                const draggableItem = document.createElement('div');
                draggableItem.className = 'draggable-item';
                draggableItem.textContent = option;
                draggableItem.setAttribute('draggable', 'true');
                draggableItem.dataset.value = option;
                
                // Add drag event listeners
                draggableItem.addEventListener('dragstart', handleDragStart);
                draggableItem.addEventListener('dragend', handleDragEnd);
                
                draggableContainer.appendChild(draggableItem);
            });
            
            questionDiv.appendChild(draggableContainer);
            
            // Create container for sentences with drop targets
            const sentencesContainer = document.createElement('div');
            sentencesContainer.className = 'sentences-container';
            
            // Process each sentence
            (question.sentences || []).forEach((sentence, sentenceIndex) => {
                const sentenceDiv = document.createElement('div');
                sentenceDiv.className = 'sentence-container';
                
                // Split the sentence by [BLANK] placeholders
                const parts = sentence.text.split('[BLANK]');
                
                // Create the sentence with drop targets
                for (let i = 0; i < parts.length; i++) {
                    // Add the text part
                    sentenceDiv.appendChild(document.createTextNode(parts[i]));
                    
                    // Add drop target after each part except the last one
                    if (i < parts.length - 1) {
                        const dropTarget = document.createElement('div');
                        dropTarget.className = 'drop-target';
                        dropTarget.dataset.sentenceIndex = sentenceIndex;
                        dropTarget.dataset.blankIndex = i;
                        dropTarget.dataset.correctAnswer = sentence.answers[i];
                        
                        // Add drop event listeners
                        dropTarget.addEventListener('dragover', handleDragOver);
                        dropTarget.addEventListener('dragenter', handleDragEnter);
                        dropTarget.addEventListener('dragleave', handleDragLeave);
                        dropTarget.addEventListener('drop', handleDrop);
                        
                        sentenceDiv.appendChild(dropTarget);
                    }
                }
                
                sentencesContainer.appendChild(sentenceDiv);
            });
            
            questionDiv.appendChild(sentencesContainer);
            
            // Add a check answers button
            const checkButton = document.createElement('button');
            checkButton.className = 'btn btn-primary mt-3';
            checkButton.textContent = 'Check Answers';
            checkButton.addEventListener('click', () => checkDragDropAnswers(questionDiv));
            questionDiv.appendChild(checkButton);
        }
        
        // Drag and drop event handlers
        function handleDragStart(e) {
            this.classList.add('dragging');
            e.dataTransfer.setData('text/plain', this.dataset.value);
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleDragEnd(e) {
            this.classList.remove('dragging');
        }
        
        function handleDragOver(e) {
            if (e.preventDefault) e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            return false;
        }
        
        function handleDragEnter(e) {
            this.classList.add('highlight');
        }
        
        function handleDragLeave(e) {
            this.classList.remove('highlight');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            this.classList.remove('highlight');
            
            const data = e.dataTransfer.getData('text/plain');
            
            // Only allow drop if the target is not already filled
            if (!this.classList.contains('filled')) {
                this.textContent = data;
                this.classList.add('filled');
                this.dataset.userAnswer = data;
                
                // Remove the draggable item from the container
                const draggedItem = document.querySelector(`.draggable-item.dragging`);
                if (draggedItem) {
                    draggedItem.style.display = 'none';
                }
                
                // Save the answer to userAnswers
                const questionIndex = currentQuestionIndex;
                const sentenceIndex = parseInt(this.dataset.sentenceIndex);
                const blankIndex = parseInt(this.dataset.blankIndex);
                
                if (!userAnswers[questionIndex]) {
                    userAnswers[questionIndex] = {};
                }
                
                if (!userAnswers[questionIndex].dragAndDrop) {
                    userAnswers[questionIndex].dragAndDrop = {};
                }
                
                if (!userAnswers[questionIndex].dragAndDrop[sentenceIndex]) {
                    userAnswers[questionIndex].dragAndDrop[sentenceIndex] = {};
                }
                
                userAnswers[questionIndex].dragAndDrop[sentenceIndex][blankIndex] = data;
            }
            
            return false;
        }
        
        function checkDragDropAnswers(questionDiv) {
            const dropTargets = questionDiv.querySelectorAll('.drop-target.filled');
            let allCorrect = true;
            
            dropTargets.forEach(target => {
                const userAnswer = target.dataset.userAnswer;
                const correctAnswer = target.dataset.correctAnswer;
                
                if (userAnswer === correctAnswer) {
                    target.classList.add('correct');
                    target.classList.remove('incorrect');
                } else {
                    target.classList.add('incorrect');
                    target.classList.remove('correct');
                    allCorrect = false;
                }
            });
            
            // Display feedback
            let feedbackDiv = questionDiv.querySelector('.feedback');
            if (!feedbackDiv) {
                feedbackDiv = document.createElement('div');
                feedbackDiv.className = 'feedback alert mt-3';
                questionDiv.appendChild(feedbackDiv);
            }
            
            if (allCorrect) {
                feedbackDiv.className = 'feedback alert alert-success mt-3';
                feedbackDiv.textContent = 'All answers are correct! Well done!';
            } else {
                feedbackDiv.className = 'feedback alert alert-danger mt-3';
                feedbackDiv.textContent = 'Some answers are incorrect. Try again!';
            }
        }
        
        function renderImageMatchingQuestion(question, questionDiv) {
            // Add instructions
            const instructionsDiv = document.createElement('div');
            instructionsDiv.className = 'question-instructions';
            instructionsDiv.textContent = 'Drag the labels to match each image.';
            questionDiv.appendChild(instructionsDiv);
            
            // Create container for draggable items (labels)
            const draggableContainer = document.createElement('div');
            draggableContainer.className = 'draggable-items-container';
            
            // Get all the options (labels to drag)
            const options = question.options || [];
            
            // Shuffle the options to display them in random order
            const shuffledOptions = [...options].sort(() => Math.random() - 0.5);
            
            // Create draggable items (labels)
            shuffledOptions.forEach(option => {
                const draggableItem = document.createElement('div');
                draggableItem.className = 'draggable-item';
                draggableItem.textContent = option;
                draggableItem.setAttribute('draggable', 'true');
                draggableItem.dataset.value = option;
                
                // Add drag event listeners
                draggableItem.addEventListener('dragstart', handleDragStart);
                draggableItem.addEventListener('dragend', handleDragEnd);
                
                draggableContainer.appendChild(draggableItem);
            });
            
            questionDiv.appendChild(draggableContainer);
            
            // Create container for images with drop targets
            const imagesContainer = document.createElement('div');
            imagesContainer.className = 'images-container';
            
            // Process each image
            (question.images || []).forEach((imageInfo, imageIndex) => {
                const imageItem = document.createElement('div');
                imageItem.className = 'image-item';
                
                // Create image element
                const img = document.createElement('img');
                img.src = imageInfo.src;
                img.alt = imageInfo.alt || `Image ${imageIndex + 1}`;
                imageItem.appendChild(img);
                
                // Create drop target for this image
                const dropTarget = document.createElement('div');
                dropTarget.className = 'image-drop-target';
                dropTarget.dataset.imageIndex = imageIndex;
                dropTarget.dataset.correctAnswer = imageInfo.correctAnswer;
                
                // Add drop event listeners
                dropTarget.addEventListener('dragover', handleDragOver);
                dropTarget.addEventListener('dragenter', handleDragEnter);
                dropTarget.addEventListener('dragleave', handleDragLeave);
                dropTarget.addEventListener('drop', handleImageDrop);
                
                imageItem.appendChild(dropTarget);
                imagesContainer.appendChild(imageItem);
            });
            
            questionDiv.appendChild(imagesContainer);
            
            // Add a check answers button
            const checkButton = document.createElement('button');
            checkButton.className = 'btn btn-primary mt-3';
            checkButton.textContent = 'Check Answers';
            checkButton.addEventListener('click', () => checkImageMatchingAnswers(questionDiv));
            questionDiv.appendChild(checkButton);
        }
        
        // Event handler for dropping on image targets
        function handleImageDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            this.classList.remove('highlight');
            
            const data = e.dataTransfer.getData('text/plain');
            
            // Only allow drop if the target is not already filled
            if (!this.classList.contains('filled')) {
                this.textContent = data;
                this.classList.add('filled');
                this.dataset.userAnswer = data;
                
                // Remove the draggable item from the container
                const draggedItem = document.querySelector(`.draggable-item.dragging`);
                if (draggedItem) {
                    draggedItem.style.display = 'none';
                }
                
                // Save the answer to userAnswers
                const questionIndex = currentQuestionIndex;
                const imageIndex = parseInt(this.dataset.imageIndex);
                
                if (!userAnswers[questionIndex]) {
                    userAnswers[questionIndex] = {};
                }
                
                if (!userAnswers[questionIndex].imageMatching) {
                    userAnswers[questionIndex].imageMatching = {};
                }
                
                userAnswers[questionIndex].imageMatching[imageIndex] = data;
            }
            
            return false;
        }
        
        function checkImageMatchingAnswers(questionDiv) {
            const dropTargets = questionDiv.querySelectorAll('.image-drop-target.filled');
            let allCorrect = true;
            
            dropTargets.forEach(target => {
                const userAnswer = target.dataset.userAnswer;
                const correctAnswer = target.dataset.correctAnswer;
                
                if (userAnswer === correctAnswer) {
                    target.classList.add('correct');
                    target.classList.remove('incorrect');
                } else {
                    target.classList.add('incorrect');
                    target.classList.remove('correct');
                    allCorrect = false;
                }
            });
            
            // Display feedback
            let feedbackDiv = questionDiv.querySelector('.feedback');
            if (!feedbackDiv) {
                feedbackDiv = document.createElement('div');
                feedbackDiv.className = 'feedback alert mt-3';
                questionDiv.appendChild(feedbackDiv);
            }
            
            if (allCorrect) {
                feedbackDiv.className = 'feedback alert alert-success mt-3';
                feedbackDiv.textContent = 'All images are correctly labeled! Great job!';
            } else {
                feedbackDiv.className = 'feedback alert alert-danger mt-3';
                feedbackDiv.textContent = 'Some labels are incorrect. Try again!';
            }
        }
        
        function renderDragAndDropAssessment(container) {
            // Safety check to ensure container exists
            if (!container) {
                console.error("Container element not found for drag-and-drop assessment");
                return;
            }

            console.log('Existing elements check:', {
                containerExists: !!container,
                containerChildren: container.children.length
            });

            // Determine if we need to clear the container (except debug info)
            if (container.children.length > 0) {
                const debugInfo = container.querySelector('.alert-info');
                // Clear everything except the debug info
                container.innerHTML = '';
                // Add back debug info if it existed
                if (debugInfo) {
                    container.appendChild(debugInfo);
                }
            }

            // Detect the assessment type and subtype
            let words = [];
            let correct = [];
            let text = '';
            let subtype = '';
            let extraWords = [];
            let audio = null;

            // Determine subtype from either assessment or question data
            if (assessment.subtype) {
                subtype = assessment.subtype;
            } else if (assessment.questions && assessment.questions.length > 0 && assessment.questions[0].subtype) {
                subtype = assessment.questions[0].subtype;
            } else if (assessment.text && (assessment.text.includes('[BLANK]') || assessment.text.includes('[blank]'))) {
                // Infer subtype from presence of [BLANK] in text
                subtype = 'long-paragraph-fill-in-blank';
            }

            // Get data from the assessment structure
            if (assessment.questions && assessment.questions.length > 0) {
                const question = assessment.questions[0];
                console.log('Found question data:', question);
                
                if (question.wordBank) words = question.wordBank;
                if (question.answers) correct = question.answers;
                if (question.correctSequence) correct = question.correctSequence;
                if (question.text) text = question.text;
                if (question.extraWords) extraWords = question.extraWords;
                if (question.audioUrl) audio = question.audioUrl;
                
                // Ensure we get the correct subtype
                if (question.subtype && !subtype) {
                    subtype = question.subtype;
                }
                console.log('Using question subtype:', subtype);
            } else {
                // Try to get data from top-level assessment object
                if (assessment.wordBank) words = assessment.wordBank;
                if (assessment.answers) correct = assessment.answers;
                if (assessment.correctSequence) correct = assessment.correctSequence;
                if (assessment.text) text = assessment.text;
                if (assessment.extraWords) extraWords = assessment.extraWords;
                if (assessment.audioUrl) audio = assessment.audioUrl;
            }

            // DON'T add extra words to the word bank - only use them to pad out the word bank if needed
            // Remove this code that adds extra words to the regular word bank
            // if (extraWords && extraWords.length > 0) {
            //     words = [...words, ...extraWords];
            // }

            console.log('Rendering drag-and-drop with subtype:', subtype);
            
            // Clear the container
            if (container.innerHTML === '') {
                container.innerHTML = `<div class="text-center">
                    <div class="spinner-border text-primary" role="status"></div>
                    <p>Preparing drag and drop exercise...</p>
                </div>`;
            }
            
            // Add debugging info
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('debug') === 'true') {
                container.innerHTML += `
                    <div class="alert alert-info mb-3">
                        <strong>Drag-and-Drop Data:</strong><br>
                        Subtype: ${subtype}<br>
                        Words: ${JSON.stringify(words)}<br>
                        Correct: ${JSON.stringify(correct)}<br>
                        Text: ${text ? text.substring(0, 50) + '...' : 'None'}<br>
                        Audio: ${audio || 'None'}
                    </div>
                `;
            }
            
            // Validate required data
            if (words.length === 0) {
                container.innerHTML = `
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        Error: No word bank provided for this drag-and-drop assessment.
                    </div>
                `;
                return;
            }

            // For long-paragraph-fill-in-blank subtype, use the improved implementation
            if (subtype === 'long-paragraph-fill-in-blank') {
                console.log('Using special long paragraph implementation for subtype:', subtype);
                
                // First, clear any existing content except debug info
                let debugInfo = container.querySelector('.alert-info');
                container.innerHTML = '';
                if (debugInfo) container.appendChild(debugInfo);
                
                // Create a div for the long paragraph exercise
                const longParagraph = document.createElement('div');
                longParagraph.className = 'long-paragraph-container';
                container.appendChild(longParagraph);
                
                // Now render specifically into this container
                renderLongParagraphDragAndDrop(longParagraph, text, words, correct);
                return;
            }

            // For other subtypes, implement as needed...
            // (rest of the function content)
        }

        // New function to render long paragraph drag and drop
        function renderLongParagraphDragAndDrop(container, text, words, answers) {
            // Validate required data
            if (!text || text.indexOf('[BLANK]') === -1) {
                container.innerHTML = `
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        Error: The question text is missing or has no blank spaces to fill in.
                    </div>
                `;
                return;
            }

            if (words.length === 0) {
                container.innerHTML = `
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        Error: No words available for the word bank.
                    </div>
                `;
                return;
            }

            // Split the text by [BLANK]
            const parts = text.split('[BLANK]');
            
            // Create the HTML
            let html = `
                <div class="card mb-4 p-4">
                    <div class="paragraph-text" style="font-size: 1.2rem; line-height: 1.8;">
            `;
            
            // Build the paragraph with blanks
            for (let i = 0; i < parts.length; i++) {
                html += parts[i];
                
                if (i < parts.length - 1) {
                    const correctAnswer = answers[i] || '';
                    html += `<span class="blank-space" 
                          id="blank-${i}" 
                          data-index="${i}" 
                          data-correct="${correctAnswer}"
                          style="display: inline-block; 
                                 min-width: 120px; 
                                 height: 35px; 
                                 border: 2px dashed #ced4da; 
                                 border-radius: 4px; 
                                 margin: 0 5px; 
                                 vertical-align: middle; 
                                 background-color: #f8f9fa;"></span>`;
                }
            }
            
            html += `
                    </div>
                </div>
                
                <div class="card mb-4 p-3">
                    <h5 class="mb-3">Word Bank:</h5>
                    <div class="word-bank" style="display: flex; flex-wrap: wrap; gap: 10px;">
            `;
            
            // Use only the valid words for the word bank, not extraWords
            // We'll make sure we're only using actual word bank items
            const wordBankItems = words.filter(word => {
                // Check if it's one of the valid answers or part of the original word bank
                // This will ensure extraWords are excluded
                const isAnswer = answers.includes(word);
                const isFromWordBank = assessment.questions && 
                    assessment.questions[0] && 
                    assessment.questions[0].wordBank && 
                    assessment.questions[0].wordBank.includes(word);
                
                return isAnswer || isFromWordBank;
            });
            
            // Shuffle the FILTERED words to display them in random order
            const shuffledWords = [...wordBankItems].sort(() => Math.random() - 0.5);
            
            // Add the word bank items
            shuffledWords.forEach((word, index) => {
                html += `<div class="word-item" 
                          id="word-${index}" 
                          data-word="${word}"
                          draggable="true"
                          style="padding: 8px 12px; 
                                 background-color: #e7f3ff; 
                                 border: 1px solid #b8daff; 
                                 border-radius: 4px; 
                                 cursor: grab; 
                                 user-select: none;">${word}</div>`;
            });
            
            html += `
                    </div>
                </div>
                
                <button id="submit-btn" class="btn btn-primary">Submit</button>
            `;
            
            // Set the HTML
            container.innerHTML = html;
            
            // Add event listeners for drag and drop
            const wordItems = document.querySelectorAll('.word-item');
            const blankSpaces = document.querySelectorAll('.blank-space');
            
            wordItems.forEach(item => {
                item.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text', this.id);
                    this.style.opacity = '0.5';
                });
                
                item.addEventListener('dragend', function() {
                    this.style.opacity = '1';
                });
            });
            
            blankSpaces.forEach(blank => {
                blank.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.style.borderColor = '#0d6efd';
                    this.style.backgroundColor = '#e7f3ff';
                });
                
                blank.addEventListener('dragleave', function() {
                    this.style.borderColor = '#ced4da';
                    this.style.backgroundColor = '#f8f9fa';
                });
                
                blank.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.style.borderColor = '#ced4da';
                    this.style.backgroundColor = '#f8f9fa';
                    
                    const id = e.dataTransfer.getData('text');
                    const wordItem = document.getElementById(id);
                    
                    if (wordItem) {
                        // If this blank already has a word, return that word to the word bank
                        if (this.dataset.wordId) {
                            const oldWordItem = document.getElementById(this.dataset.wordId);
                            if (oldWordItem) {
                                oldWordItem.style.display = '';
                            }
                        }
                        
                        // Set the text content
                        this.textContent = wordItem.textContent;
                        
                        // Store which word is in this blank
                        this.dataset.wordId = wordItem.id;
                        
                        // Style the blank
                        this.style.border = '2px solid #6c757d';
                        this.style.backgroundColor = '#e9ecef';
                        this.style.textAlign = 'center';
                        this.style.padding = '5px';
                        this.style.fontWeight = '500';
                        
                        // Hide the word item
                        wordItem.style.display = 'none';
                    }
                });
            });
            
            // Add submit button handler
            document.getElementById('submit-btn').addEventListener('click', function() {
                // Collect answers
                const answers = [];
                let correctCount = 0;
                let totalCount = blankSpaces.length;
                
                blankSpaces.forEach((blank, index) => {
                    const userAnswer = blank.textContent;
                    const correctAnswer = blank.dataset.correct;
                    
                    answers.push({
                        index,
                        userAnswer,
                        correctAnswer,
                        isCorrect: userAnswer === correctAnswer
                    });
                    
                    if (userAnswer === correctAnswer) {
                        correctCount++;
                        blank.style.borderColor = '#28a745';
                        blank.style.backgroundColor = '#d4edda';
                    } else {
                        blank.style.borderColor = '#dc3545';
                        blank.style.backgroundColor = '#f8d7da';
                    }
                });
                
                // Calculate score
                const score = Math.round((correctCount / totalCount) * 100);
                
                // Show score
                alert(`Your score: ${score}% (${correctCount} out of ${totalCount} correct)`);
                
                // Submit to server if needed
                if (window.submitAssessment) {
                    window.submitAssessment({
                        answers,
                        score
                    });
                }
            });
        }

        function submitDragDropAssessment(container) {
            console.log('Submitting drag-drop assessment...');
            
            // Detect subtype
            let subtype = assessment.subtype;
            if (!subtype && assessment.questions && assessment.questions[0]) {
                subtype = assessment.questions[0].subtype;
            }
            
            console.log('Assessment subtype for submission:', subtype);
            
            let correctCount = 0;
            let totalCount = 0;
            let answerData = {};
            
            if (subtype === 'long-paragraph-fill-in-blank') {
                // For long paragraph, collect answers from the drop targets
                const dropTargets = document.querySelectorAll('.drop-target');
                totalCount = dropTargets.length;
                
                // Record each answer and check if correct
                dropTargets.forEach((target, index) => {
                    const userAnswer = target.textContent;
                    // Find the correct answer - could be in different places depending on the data structure
                    let correctAnswer = null;
                    
                    if (assessment.questions && assessment.questions[0] && assessment.questions[0].answers) {
                        correctAnswer = assessment.questions[0].answers[index];
                    } else if (assessment.answers) {
                        correctAnswer = assessment.answers[index];
                    }
                    
                    // Record the answer regardless of whether we found a correct answer
                    answerData[`answer_${index}`] = userAnswer;
                    
                    // Check if correct (if we have a correct answer to compare against)
                    if (correctAnswer && userAnswer) {
                        const isCorrect = userAnswer.trim().toLowerCase() === correctAnswer.trim().toLowerCase();
                        answerData[`correct_${index}`] = isCorrect;
                        if (isCorrect) correctCount++;
                    }
                });
            } 
            else if (subtype === 'sequence') {
                // For sequence, collect answers from the drop targets in order
                const dropTargets = document.querySelectorAll('.drop-target');
                totalCount = dropTargets.length;
                
                // Get the expected sequence from the assessment
                let correctSequence = [];
                if (assessment.questions && assessment.questions[0] && assessment.questions[0].correctSequence) {
                    correctSequence = assessment.questions[0].correctSequence;
                } else if (assessment.correct) {
                    correctSequence = assessment.correct;
                }
                
                // Check each position in the sequence
                dropTargets.forEach((target, index) => {
                    const userAnswer = target.textContent;
                    const correctAnswer = correctSequence[index];
                    
                    // Record the answer
                    answerData[`answer_${index}`] = userAnswer;
                    
                    // Check if this position is correct
                    if (correctAnswer && userAnswer) {
                        const isCorrect = userAnswer.trim() === correctAnswer.trim();
                        answerData[`correct_${index}`] = isCorrect;
                        if (isCorrect) correctCount++;
                    }
                });
            }
            else {
                // Default handling for other subtypes
                const dropTargets = document.querySelectorAll('.drop-target.filled');
                totalCount = dropTargets.length;
                
                // Check each drop target
                dropTargets.forEach((target, index) => {
                    const userAnswer = target.textContent;
                    const correctAnswer = target.dataset.correctAnswer;
                    
                    // Record the answer
                    answerData[`answer_${index}`] = userAnswer;
                    
                    // Check if correct
                    if (correctAnswer && userAnswer) {
                        const isCorrect = userAnswer.trim() === correctAnswer.trim();
                        answerData[`correct_${index}`] = isCorrect;
                        if (isCorrect) correctCount++;
                    }
                });
            }
            
            // Calculate score as percentage
            let score = 0;
            if (totalCount > 0) {
                score = Math.round((correctCount / totalCount) * 100);
            }
            
            console.log('Assessment submission results:', {
                totalQuestions: totalCount,
                correctAnswers: correctCount,
                score: score,
                answerData: answerData
            });
            
            // Set up the submission data
            const submissionData = {
                answers: answerData,
                score: score
            };
            
            // Show submission confirmation dialog
            if (confirm(`Are you sure you want to submit this assessment? Your score is ${score}%.`)) {
                // Submit to the server
                submitAssessment(submissionData);
            }
        }

        // Add loader functions
        function showLoader() {
            // Check if loader exists, create if not
            let loader = document.getElementById('loader');
            if (!loader) {
                loader = document.createElement('div');
                loader.id = 'loader';
                loader.className = 'position-fixed top-0 start-0 w-100 h-100 d-flex justify-content-center align-items-center bg-white bg-opacity-75';
                loader.style.zIndex = '9999';
                loader.innerHTML = `
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                `;
                document.body.appendChild(loader);
            } else {
                loader.style.display = 'flex';
            }
        }
        
        function hideLoader() {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.style.display = 'none';
            }
        }

        // Sample drag-and-drop question for testing
        const sampleDragDropQuestion = {
            type: 'drag-and-drop',
            text: 'Fill in the blanks in the following sentences with the correct words.',
            options: ['happy', 'sad', 'angry', 'excited', 'tired', 'hungry', 'thirsty'],
            sentences: [
                {
                    text: 'I am [BLANK] to see you today!',
                    answers: ['happy']
                },
                {
                    text: 'She was [BLANK] because she lost her favorite toy.',
                    answers: ['sad']
                },
                {
                    text: 'After running, I was [BLANK] and [BLANK].',
                    answers: ['tired', 'thirsty']
                }
            ]
        };
        
        // Function to test the drag-and-drop functionality
        function testDragAndDrop() {
            // Create a container 
            const container = document.getElementById('assessmentContainer');
            container.innerHTML = `
                <div class="container mt-5">
                    <h2>Drag and Drop Test</h2>
                    <div id="questionContainer"></div>
                    <button class="btn btn-secondary mt-3" onclick="window.location.reload()">Reset Test</button>
                </div>
            `;
            
            // Create the question div
            const questionDiv = document.createElement('div');
            questionDiv.className = 'question-container';
            
            // Render the drag-and-drop question
            renderDragAndDropQuestion(sampleDragDropQuestion, questionDiv);
            
            // Add to the container
            document.getElementById('questionContainer').appendChild(questionDiv);
        }
        
        // Sample image-matching question for testing
        const sampleImageMatchingQuestion = {
            type: 'image-matching',
            text: 'Match the correct labels with each medical image.',
            options: ['a doctor', 'a nurse', 'have a fever', 'take a temperature'],
            images: [
                {
                    src: 'https://img.freepik.com/free-photo/portrait-smiling-handsome-male-doctor-man_171337-5055.jpg',
                    alt: 'Doctor in white coat with stethoscope',
                    correctAnswer: 'a doctor'
                },
                {
                    src: 'https://img.freepik.com/free-photo/portrait-smiling-male-nurse_171337-1064.jpg',
                    alt: 'Nurse in scrubs',
                    correctAnswer: 'a nurse'
                },
                {
                    src: 'https://img.freepik.com/free-photo/sick-woman-bed-having-fever-measuring-body-temperature_1301-7724.jpg',
                    alt: 'Patient with thermometer',
                    correctAnswer: 'have a fever'
                },
                {
                    src: 'https://img.freepik.com/free-photo/woman-measuring-temperature-girl-bed_1301-2173.jpg',
                    alt: 'Person taking temperature',
                    correctAnswer: 'take a temperature'
                }
            ]
        };
        
        // Function to test the image-matching functionality
        function testImageMatching() {
            // Create a container 
            const container = document.getElementById('assessmentContainer');
            container.innerHTML = `
                <div class="container mt-5">
                    <h2>Image Matching Test</h2>
                    <div id="questionContainer"></div>
                    <button class="btn btn-secondary mt-3" onclick="window.location.reload()">Reset Test</button>
                </div>
            `;
            
            // Create the question div
            const questionDiv = document.createElement('div');
            questionDiv.className = 'question-container';
            
            // Render the image-matching question
            renderImageMatchingQuestion(sampleImageMatchingQuestion, questionDiv);
            
            // Add to the container
            document.getElementById('questionContainer').appendChild(questionDiv);
        }
        
        // To test both types, add buttons to switch between them
        function showTestOptions() {
            const container = document.getElementById('assessmentContainer');
            container.innerHTML = `
                <div class="container mt-5">
                    <h2>Drag & Drop Testing</h2>
                    <p>Select which type of drag & drop questions you want to test:</p>
                    <div class="d-flex gap-3 mt-4">
                        <button class="btn btn-primary" onclick="testDragAndDrop()">
                            Test Sentence Completion
                        </button>
                        <button class="btn btn-primary" onclick="testImageMatching()">
                            Test Image Matching
                        </button>
                    </div>
                </div>
            `;
        }
        
        // Uncomment this line to show test options immediately
        // document.addEventListener('DOMContentLoaded', showTestOptions);

        function startAttemptTimer() {
            clearInterval(timerInterval);
            attemptStartTime = Date.now();
            updateTimerDisplay();
            timerInterval = setInterval(updateTimerDisplay, 1000);
        }

        function updateTimerDisplay() {
            if (!attemptStartTime) return;
            const elapsed = Math.floor((Date.now() - attemptStartTime) / 1000);
            const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
            const seconds = String(elapsed % 60).padStart(2, '0');
            document.getElementById('timer').textContent = `${minutes}:${seconds}`;
        }

        function stopAttemptTimer() {
            if (!attemptStartTime) return 0;
            clearInterval(timerInterval);
            const elapsed = Math.floor((Date.now() - attemptStartTime) / 1000);
            totalTime += elapsed;
            attemptStartTime = null;
            return elapsed;
        }

        function renderTrueFalseQuestion(question, questionDiv) {
            // Add instructions if present
            if (question.instructions) {
                const instructionsDiv = document.createElement('div');
                instructionsDiv.className = 'question-instructions';
                instructionsDiv.textContent = question.instructions;
                questionDiv.appendChild(instructionsDiv);
            }
            // Render each sentence with T/F toggles
            const sentencesDiv = document.createElement('div');
            sentencesDiv.className = 'tf-sentences';
            userAnswers[currentQuestionIndex] = userAnswers[currentQuestionIndex] || { tf: [] };
            question.sentences.forEach((sentence, idx) => {
                const row = document.createElement('div');
                row.className = 'tf-sentence-row mb-2 d-flex align-items-center';
                const text = document.createElement('span');
                text.textContent = sentence.text;
                text.style.flex = '1';
                row.appendChild(text);
                // T/F toggle button
                const tfBtn = document.createElement('button');
                tfBtn.type = 'button';
                tfBtn.className = 'btn btn-outline-secondary tf-toggle ms-2';
                tfBtn.dataset.state = '';
                tfBtn.textContent = '?';
                // Set initial state if already answered
                const saved = userAnswers[currentQuestionIndex].tf[idx];
                if (saved === true) {
                    tfBtn.dataset.state = 'T';
                    tfBtn.textContent = 'T';
                    tfBtn.classList.add('btn-success');
                } else if (saved === false) {
                    tfBtn.dataset.state = 'F';
                    tfBtn.textContent = 'F';
                    tfBtn.classList.add('btn-danger');
                }
                tfBtn.onclick = function() {
                    const states = ['', 'T', 'F'];
                    let stateIdx = states.indexOf(tfBtn.dataset.state || '');
                    stateIdx = (stateIdx + 1) % states.length;
                    tfBtn.dataset.state = states[stateIdx];
                    tfBtn.textContent = states[stateIdx] || '?';
                    tfBtn.classList.toggle('btn-success', states[stateIdx] === 'T');
                    tfBtn.classList.toggle('btn-danger', states[stateIdx] === 'F');
                    tfBtn.classList.toggle('btn-outline-secondary', states[stateIdx] === '');
                    // Save answer
                    userAnswers[currentQuestionIndex].tf[idx] = states[stateIdx] === 'T' ? true : states[stateIdx] === 'F' ? false : null;
                };
                row.appendChild(tfBtn);
                sentencesDiv.appendChild(row);
            });
            questionDiv.appendChild(sentencesDiv);
        }

        // Update the startRecording function
        function startRecording(questionIndex, isVideo) {
            const constraints = {
                audio: true,
                video: isVideo ? {
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                } : false
            };

            navigator.mediaDevices.getUserMedia(constraints)
                .then(stream => {
                    const mediaRecorder = new MediaRecorder(stream);
                    const chunks = [];
                    
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            chunks.push(e.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: isVideo ? 'video/webm' : 'audio/webm' });
                        const url = URL.createObjectURL(blob);
                        
                        const previewDiv = document.getElementById(`mediaPreview${questionIndex}`);
                        previewDiv.innerHTML = isVideo ? 
                            `<video controls class="w-100"><source src="${url}" type="video/webm"></video>` :
                            `<audio controls class="w-100"><source src="${url}" type="audio/webm"></audio>`;
                        
                        // Store the blob for later upload
                        window.recordedMedia = {
                            blob: blob,
                            type: isVideo ? 'video' : 'audio'
                        };
                        
                        document.getElementById(`uploadBtn${questionIndex}`).style.display = 'inline-block';
                    };
                    
                    // Start recording
                    mediaRecorder.start();
                    window.mediaRecorder = mediaRecorder;
                    window.recordingStream = stream;
                    
                    // Update UI
                    document.getElementById(`recordBtn${questionIndex}`).style.display = 'none';
                    document.getElementById(`stopBtn${questionIndex}`).style.display = 'inline-block';
                    
                    // Start timer
                    const timeLimit = parseInt(document.querySelector(`#question${questionIndex} .progress`).parentElement.textContent.match(/\d+/)[0]);
                    let timeLeft = timeLimit;
                    const progressBar = document.querySelector(`#question${questionIndex} .progress-bar`);
                    const statusDiv = document.getElementById(`recordingStatus${questionIndex}`);
                    
                    const timer = setInterval(() => {
                        timeLeft--;
                        const progress = ((timeLimit - timeLeft) / timeLimit) * 100;
                        progressBar.style.width = `${progress}%`;
                        statusDiv.textContent = `Recording... ${timeLeft} seconds left`;
                        
                        if (timeLeft <= 0) {
                            clearInterval(timer);
                            stopRecording(questionIndex);
                        }
                    }, 1000);
                    
                    window.recordingTimer = timer;
                })
                .catch(error => {
                    console.error('Error accessing media devices:', error);
                    alert('Error accessing media devices. Please make sure you have granted the necessary permissions.');
                });
        }

        // Update the uploadMedia function
        function uploadMedia(questionIndex) {
            if (!window.recordedMedia) {
                alert('Please record your response first');
                return;
            }

            const formData = new FormData();
            formData.append('media', window.recordedMedia.blob, `recording.${window.recordedMedia.type === 'video' ? 'webm' : 'webm'}`);
            formData.append('type', window.recordedMedia.type);

            fetch(`/api/assessments/${assessmentId}/submit-speaking`, {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Recording uploaded successfully');
                    // Clear the recording
                    window.recordedMedia = null;
                    document.getElementById(`mediaPreview${questionIndex}`).innerHTML = '';
                    document.getElementById(`uploadBtn${questionIndex}`).style.display = 'none';
                } else {
                    alert('Error uploading recording: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error uploading recording');
            });
        }

        function renderWritingQuestion(question, questionDiv, index) {
            // Render a short answer input for writing questions
            const promptDiv = document.createElement('div');
            promptDiv.className = 'question-text';
            promptDiv.innerText = question.text;
            questionDiv.appendChild(promptDiv);

            const inputGroup = document.createElement('div');
            inputGroup.className = 'input-group mb-3';
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'form-control';
            input.placeholder = 'Type your answer here...';
            if (userAnswers[index] && userAnswers[index].text) {
                input.value = userAnswers[index].text;
            }
            input.addEventListener('input', function() {
                if (!userAnswers[index]) userAnswers[index] = {};
                userAnswers[index].text = this.value;
            });
            inputGroup.appendChild(input);
            questionDiv.appendChild(inputGroup);
        }

        function renderWritingAssessment(container, question, assessment) {
            container.innerHTML = '';
            const form = document.createElement('form');
            form.className = 'writing-form';
            let inputGroup = '';
            if (question.subtype === 'long-answer') {
                // Only allow image upload
                inputGroup = `
                    <div class="mb-3">
                        <label for="writingImage" class="form-label">Upload a photo of your handwritten answer:</label>
                        <input type="file" accept="image/*" class="form-control" id="writingImage" name="writingImage" required>
                    </div>
                `;
            } else if (question.subtype === 'short-answer') {
                // Allow text input and/or image upload
                inputGroup = `
                    <div class="mb-3">
                        <label for="writingText" class="form-label">Type your answer (optional):</label>
                        <textarea class="form-control" id="writingText" name="writingText" rows="3"></textarea>
                    </div>
                    <div class="mb-3">
                        <label for="writingImage" class="form-label">Or upload a photo of your answer (optional):</label>
                        <input type="file" accept="image/*" class="form-control" id="writingImage" name="writingImage">
                    </div>
                `;
            }
            form.innerHTML = inputGroup + `
                <button type="submit" class="btn btn-primary">Submit</button>
            `;
            container.appendChild(form);
            form.onsubmit = async function(e) {
                e.preventDefault();
                const formData = new FormData();
                if (question.subtype === 'long-answer') {
                    const file = form.writingImage.files[0];
                    if (!file) {
                        alert('Please upload an image.');
                        return;
                    }
                    formData.append('image', file);
                } else if (question.subtype === 'short-answer') {
                    if (form.writingText.value) formData.append('text', form.writingText.value);
                    if (form.writingImage.files[0]) formData.append('image', form.writingImage.files[0]);
                }
                // Submit to backend
                const res = await fetch(`/api/assessments/${assessment.id}/submit-writing`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` },
                    body: formData
                });
                const result = await res.json();
                if (result.success) {
                    alert('Submission successful!');
                    // Once submitted, fetch submission data to update the attempts counter
                    await fetchSubmissionData();
                    window.location.reload();
                } else {
                    alert('Submission failed: ' + (result.error || 'Unknown error'));
                }
            };
        }

        function showError(message) {
            const container = document.getElementById('assessmentContainer');
            container.style.display = 'block';
            container.innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle-fill me-2"></i>
                    ${message}
                </div>
                <a href="/student/assessments" class="btn btn-primary">
                    <i class="bi bi-arrow-left me-2"></i>Back to Assessments
                </a>
            `;
            hideLoader();
        }
        
        function showMaxAttemptsReached() {
            const container = document.getElementById('assessmentContainer');
            container.style.display = 'block';
            container.innerHTML = `
                <div class="alert alert-warning">
                    <i class="bi bi-exclamation-circle-fill me-2"></i>
                    You have reached the maximum number of attempts for this assessment.
                </div>
                <div class="mt-3">
                    <h4>Your Submissions</h4>
                    <ul class="list-group">
                        ${submissionData.map(submission => `
                            <li class="list-group-item">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <strong>Submitted:</strong> ${new Date(submission.submittedAt).toLocaleString()}
                                    </div>
                                    <div>
                                        <strong>Score:</strong> ${submission.score !== null ? submission.score + '%' : 'Pending'}
                                    </div>
                                </div>
                            </li>
                        `).join('')}
                    </ul>
                </div>
                <a href="/student/assessments" class="btn btn-primary mt-3">
                    <i class="bi bi-arrow-left me-2"></i>Back to Assessments
                </a>
            `;
            hideLoader();
        }

        function setupRecording() {
            const startBtn = document.getElementById('startRecordingBtn');
            const stopBtn = document.getElementById('stopRecordingBtn');
            const statusDiv = document.getElementById('recordingStatus');
            const timerDiv = document.getElementById('recordingTimer');
            const audioPreview = document.getElementById('audioPreview');
            const audioPlayer = document.getElementById('audioPlayer');
            const submitBtn = document.getElementById('submitRecordingBtn');
            
            let mediaRecorder;
            let audioChunks = [];
            let recordingInterval;
            let recordingDuration = 0;
            
            startBtn.addEventListener('click', function() {
                // Reset previous recording
                audioChunks = [];
                recordingDuration = 0;
                audioPlayer.src = '';
                audioPreview.style.display = 'none';
                submitBtn.style.display = 'none';
                
                // Update UI
                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-block';
                timerDiv.style.display = 'block';
                timerDiv.textContent = '00:00';
                
                // Create recording indicator with animation
                statusDiv.innerHTML = `
                    <div class="d-flex align-items-center text-danger">
                        <div class="recording-dot pulsing me-2"></div>
                        <span>Recording...</span>
                    </div>
                `;
                
                // Update timer every second
                recordingInterval = setInterval(function() {
                    recordingDuration++;
                    const minutes = Math.floor(recordingDuration / 60).toString().padStart(2, '0');
                    const seconds = (recordingDuration % 60).toString().padStart(2, '0');
                    timerDiv.textContent = `${minutes}:${seconds}`;
                }, 1000);
                
                // Request microphone access
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        mediaRecorder = new MediaRecorder(stream);
                        
                        mediaRecorder.ondataavailable = e => {
                            if (e.data.size > 0) {
                                audioChunks.push(e.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            clearInterval(recordingInterval);
                            
                            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                            const audioUrl = URL.createObjectURL(audioBlob);
                            audioPlayer.src = audioUrl;
                            audioPreview.style.display = 'block';
                            submitBtn.style.display = 'block';
                            
                            // Store for submission
                            window.recordedAudio = audioBlob;
                        };
                        
                        mediaRecorder.start();
                    })
                    .catch(error => {
                        console.error('Error accessing microphone:', error);
                        statusDiv.innerHTML = `<div class="text-danger">Error: Unable to access microphone. Please check permissions.</div>`;
                        startBtn.style.display = 'inline-block';
                        stopBtn.style.display = 'none';
                        clearInterval(recordingInterval);
                    });
            });
            
            stopBtn.addEventListener('click', function() {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                    
                    // Stop all tracks in the stream
                    mediaRecorder.stream.getTracks().forEach(track => track.stop());
                }
                
                // Update UI
                startBtn.style.display = 'inline-block';
                stopBtn.style.display = 'none';
                statusDiv.innerHTML = '<div class="text-success">Recording complete! You can preview or re-record.</div>';
            });
            
            submitBtn.addEventListener('click', async function() {
                if (!window.recordedAudio) {
                    statusDiv.innerHTML = '<div class="text-danger">No recording available to submit.</div>';
                    return;
                }
                
                // Disable button during submission
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Submitting...';
                statusDiv.innerHTML = '<div class="text-primary">Submitting recording...</div>';
                
                // Create form data and add audio blob
                const formData = new FormData();
                formData.append('audio', window.recordedAudio, 'recording.webm');
                
                try {
                    // Submit to API
                    const response = await fetch(`/api/assessments/${assessment.id}/submit-speaking`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`
                        },
                        body: formData
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok && data.success) {
                        // Show success message
                        container.innerHTML = `
                            <div class="alert alert-success">
                                <h4 class="alert-heading">Success!</h4>
                                <p>Your speaking assessment has been submitted successfully.</p>
                                <hr>
                                <p class="mb-0">You will receive feedback from your teacher soon.</p>
                            </div>
                            <a href="/student/assessments" class="btn btn-primary">
                                <i class="bi bi-arrow-left"></i> Back to Assessments
                            </a>
                        `;
                    } else {
                        throw new Error(data.error || 'Unknown error');
                    }
                } catch (error) {
                    console.error('Error submitting recording:', error);
                    statusDiv.innerHTML = `<div class="alert alert-danger">Error submitting recording: ${error.message || 'Unknown error'}</div>`;
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<i class="bi bi-check-circle"></i> Submit Recording';
                }
            });
        }

        function setupMatchingAssessment() {
            const container = document.getElementById('matchingContainer');
            const checkBtn = document.getElementById('checkMatchingBtn');
            const submitBtn = document.getElementById('submitMatchingBtn');
            
            // Ensure userAnswers is initialized
            if (!window.userAnswers) {
                window.userAnswers = [];
            }
            
            // Get matching pairs from the assessment data
            let pairs = [];
            
            // Extract pairs from questions
            if (assessment.questions && Array.isArray(assessment.questions)) {
                const matchingQuestion = assessment.questions.find(q => q.type === 'matching');
                if (matchingQuestion) {
                    // If pairs are directly available in the question
                    if (matchingQuestion.pairs && Array.isArray(matchingQuestion.pairs)) {
                        pairs = matchingQuestion.pairs;
                    }
                    // If expressions and meanings are available, create pairs
                    else if (matchingQuestion.expressions && matchingQuestion.meanings && 
                            Array.isArray(matchingQuestion.expressions) && 
                            Array.isArray(matchingQuestion.meanings)) {
                        pairs = [];
                        for (let i = 0; i < Math.min(matchingQuestion.expressions.length, matchingQuestion.meanings.length); i++) {
                            pairs.push({
                                expression: matchingQuestion.expressions[i],
                                meaning: matchingQuestion.meanings[i]
                            });
                        }
                    }
                }
            }
            
            // Clear the container and create the matching interface
            container.innerHTML = '';
            
            if (pairs.length > 0) {
                // Create array of meanings and shuffle them
                const meanings = pairs.map(pair => pair.meaning);
                const shuffledMeanings = shuffleArray([...meanings]);
                
                // Create the matching interface
                const matchingTable = document.createElement('div');
                matchingTable.className = 'matching-table';
                
                // Create a container for feedback
                const feedbackElement = document.createElement('div');
                feedbackElement.id = 'matchingFeedback';
                feedbackElement.className = 'mt-3';
                
                pairs.forEach((pair, index) => {
                    const expressionDiv = document.createElement('div');
                    expressionDiv.className = 'mb-2'; // Reduced spacing
                    expressionDiv.innerHTML = `
                        <div class="card-body p-2"> <!-- Reduced padding -->
                            <div class="row align-items-center">
                                <div class="col-sm-5">
                                    <div class="expression-item" style="font-size: 1.2rem; font-weight: 500;">${pair.expression}</div>
                                </div>
                                <div class="col-sm-1 text-center p-0">
                                    <span class="arrow">→</span>
                                </div>
                                <div class="col-sm-6">
                                    <select class="form-select matching-select" id="option-${index}" style="font-size: 1.2rem;">
                                        <option value="">-- Select --</option>
                                        ${shuffledMeanings.map((meaning, i) => `<option value="meaning-${meanings.indexOf(meaning)}">${meaning}</option>`).join('')}
                                    </select>
                                </div>
                            </div>
                        </div>
                    `;
                    container.appendChild(expressionDiv);
                });
                
                container.appendChild(feedbackElement);
                
                // Add event listeners for check and submit buttons
                checkBtn.addEventListener('click', function() {
                    const result = checkMatching();
                    // Record first attempt
                    if (!userAnswers[0] || !userAnswers[0].hasBeenChecked) {
                        // Save the first attempt result
                        if (!userAnswers[0]) userAnswers[0] = {};
                        userAnswers[0].score = result.score;
                        userAnswers[0].hasBeenChecked = true;
                        console.log('First attempt score recorded:', result.score);
                    }
                });
                
                submitBtn.addEventListener('click', submitMatching);
            } else {
                container.innerHTML = `
                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        No matching pairs found for this assessment.
                    </div>
                `;
                checkBtn.disabled = true;
                submitBtn.disabled = true;
            }
        }

        function checkMatching() {
            // Ensure userAnswers is initialized
            if (!window.userAnswers) {
                window.userAnswers = [];
            }
            
            const container = document.getElementById('matchingContainer');
            const selectElements = container.querySelectorAll('.matching-select');
            const matchingPairs = {};
            let correctCount = 0;
            
            selectElements.forEach((select, index) => {
                const userSelection = select.value;
                // Extract the index from the value (meaning-X format)
                const selectedMeaningIndex = userSelection ? parseInt(userSelection.split('-')[1]) : -1;
                // The correct meaning would be the one with the same index as the expression
                const isCorrect = selectedMeaningIndex === index;
                
                matchingPairs[`option-${index}`] = userSelection;
                
                if (isCorrect) {
                    correctCount++;
                    select.classList.add('is-valid');
                    select.classList.remove('is-invalid');
                } else {
                    select.classList.add('is-invalid');
                    select.classList.remove('is-valid');
                }
            });
            
            const totalPairs = selectElements.length;
            const score = Math.round((correctCount / totalPairs) * 100);
            
            const feedbackElement = document.getElementById('matchingFeedback');
            feedbackElement.innerHTML = `
                <div class="alert alert-info mt-3">
                    <strong>Score:</strong> ${score}% (${correctCount} out of ${totalPairs} correct)
                </div>
            `;
            
            return {score, correctCount, totalPairs};
        }

        async function submitMatching() {
            // Ensure userAnswers is initialized
            if (!window.userAnswers) {
                window.userAnswers = [];
            }
            
            const container = document.getElementById('matchingContainer');
            const selectElements = container.querySelectorAll('.matching-select');
            const matchingPairs = {};
            let correctCount = 0;
            
            selectElements.forEach((select, index) => {
                const userSelection = select.value;
                // Extract the index from the value (meaning-X format)
                const selectedMeaningIndex = userSelection ? parseInt(userSelection.split('-')[1]) : -1;
                // The correct meaning would be the one with the same index as the expression
                const isCorrect = selectedMeaningIndex === index;
                
                matchingPairs[`option-${index}`] = userSelection;
                
                if (isCorrect) correctCount++;
            });
            
            const totalPairs = selectElements.length;
            const score = Math.round((correctCount / totalPairs) * 100);
            
            // Use the score from the first check if available
            const finalScore = (window.userAnswers[0] && window.userAnswers[0].hasBeenChecked) ? 
                window.userAnswers[0].score : score;
            
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/assessments/${assessment.id}/submit`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        answers: [matchingPairs],
                        score: finalScore
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('checkMatchingBtn').disabled = true;
                    document.getElementById('submitMatchingBtn').disabled = true;
                    
                    // Show submission results
                    const feedbackElement = document.getElementById('matchingFeedback');
                    feedbackElement.innerHTML = `
                        <div class="alert alert-success mt-3">
                            <strong>Assessment submitted!</strong><br>
                            Score: ${finalScore}% 
                            ${(window.userAnswers[0] && window.userAnswers[0].hasBeenChecked) ? 
                                '(Based on your first attempt)' : ''}
                        </div>
                    `;
                    
                    // Show a more visible success message
                    alert('Assessment submitted successfully!');
                    
                    // Increment the attempt count displayed
                    const attemptCount = document.getElementById('attemptCount');
                    if (attemptCount) {
                        attemptCount.textContent = (parseInt(attemptCount.textContent) + 1).toString();
                    }
                } else {
                    alert('Failed to submit assessment. Please try again.');
                }
            } catch (error) {
                console.error('Error submitting matching assessment:', error);
                alert('Failed to submit assessment. Please try again.');
            }
        }

        function createLongParagraphFillInBlanks(question) {
            console.log('Creating long paragraph with:', question);
            
            // Create the container
            const container = document.createElement('div');
            container.className = 'long-paragraph-container';
            
            // Create the paragraph with drop targets
            const paragraphText = question.text || '';
            if (!paragraphText) {
                console.error('No paragraph text provided for long paragraph fill-in-blank question');
                return container;
            }
            
            const parts = paragraphText.split('[BLANK]');
            if (parts.length <= 1) {
                console.error('No [BLANK] placeholders found in paragraph text');
                container.innerHTML = `
                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        No blank placeholders found in the paragraph text.
                    </div>
                    <div class="paragraph-text">${paragraphText}</div>
                `;
                return container;
            }
            
            // Create the HTML for paragraph with drop targets
            // Use a more structured approach for better formatting
            const paragraphContainer = document.createElement('div');
            paragraphContainer.className = 'paragraph-container card p-4 mb-4';
            paragraphContainer.style.fontSize = '1.2rem';
            paragraphContainer.style.lineHeight = '1.8';
            
            const sentenceContainer = document.createElement('div');
            sentenceContainer.className = 'sentence-container';
            
            // Properly format the paragraph with drop targets
            for (let i = 0; i < parts.length; i++) {
                // Add the text part with proper spacing
                const textSpan = document.createElement('span');
                textSpan.textContent = parts[i];
                sentenceContainer.appendChild(textSpan);
                
                // Add a drop target after each part except the last one
                if (i < parts.length - 1) {
                    const dropTarget = document.createElement('span');
                    dropTarget.className = 'drop-target';
                    dropTarget.id = `target-${i}`;
                    dropTarget.dataset.index = i;
                    dropTarget.style.display = 'inline-block';
                    dropTarget.style.minWidth = '120px';
                    dropTarget.style.height = '35px';
                    dropTarget.style.margin = '0 5px';
                    dropTarget.style.verticalAlign = 'middle';
                    dropTarget.style.border = '2px dashed #ced4da';
                    dropTarget.style.borderRadius = '4px';
                    dropTarget.style.backgroundColor = '#f8f9fa';
                    dropTarget.addEventListener('dragover', allowDrop);
                    dropTarget.addEventListener('drop', drop);
                    sentenceContainer.appendChild(dropTarget);
                }
            }
            
            paragraphContainer.appendChild(sentenceContainer);
            
            // Get word bank
            const wordBank = [...(question.wordBank || [])];
            // Add extra words if available
            if (question.extraWords && question.extraWords.length) {
                wordBank.push(...question.extraWords);
            }
            
            // If no word bank, use the answers as a fallback
            if (wordBank.length === 0 && question.answers && question.answers.length) {
                wordBank.push(...question.answers);
            }
            
            // If still no word bank, show an error
            if (wordBank.length === 0) {
                console.error('No word bank provided for long paragraph fill-in-blank question');
                container.innerHTML = paragraphContainer.outerHTML + `
                    <div class="alert alert-warning mt-3">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        No word bank provided for this exercise.
                    </div>
                `;
                return container;
            }
            
            // Create word bank container with better styling
            const wordBankSection = document.createElement('div');
            wordBankSection.className = 'mb-4';
            
            const wordBankHeader = document.createElement('h5');
            wordBankHeader.className = 'mb-3';
            wordBankHeader.innerHTML = '<strong>Word Bank:</strong>';
            wordBankSection.appendChild(wordBankHeader);
            
            // Shuffle the word bank
            const shuffledWordBank = [...wordBank].sort(() => Math.random() - 0.5);
            
            // Create word bank items with improved styling
            const draggableContainer = document.createElement('div');
            draggableContainer.className = 'draggable-items-container';
            draggableContainer.style.display = 'flex';
            draggableContainer.style.flexWrap = 'wrap';
            draggableContainer.style.gap = '10px';
            draggableContainer.style.padding = '15px';
            draggableContainer.style.backgroundColor = '#f8f9fa';
            draggableContainer.style.borderRadius = '5px';
            draggableContainer.style.border = '1px solid #dee2e6';
            
            shuffledWordBank.forEach((word, index) => {
                const draggableItem = document.createElement('div');
                draggableItem.className = 'draggable-item';
                draggableItem.id = `item-${index}`;
                draggableItem.textContent = word;
                draggableItem.setAttribute('draggable', 'true');
                draggableItem.dataset.value = word;
                
                // Add drag event listeners
                draggableItem.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text', draggableItem.id);
                    draggableItem.classList.add('dragging');
                    draggableItem.style.opacity = '0.5';
                });
                
                draggableItem.addEventListener('dragend', function() {
                    draggableItem.classList.remove('dragging');
                    draggableItem.style.opacity = '1';
                });
                
                draggableContainer.appendChild(draggableItem);
            });
            
            wordBankSection.appendChild(draggableContainer);
            
            // Get the correct answers
            const correctAnswers = question.answers || question.correct || [];
            
            // Add hidden input fields to store data, but without 'required' attribute
            const hiddenInputsHtml = `
                <div style="display:none;">
                    <input type="hidden" id="long_paragraph_result" name="long_paragraph_result" value="">
                    ${correctAnswers.map((answer, i) => `
                        <input type="hidden" id="expression_question_${question.id || Date.now()}_${i}" name="expression_question_${question.id || Date.now()}_${i}" value="${answer}">
                        <input type="hidden" id="meaning_question_${question.id || Date.now()}_${i}" name="meaning_question_${question.id || Date.now()}_${i}" value="">
                    `).join('')}
                </div>
            `;
            
            // Add debug information if needed
            const urlParams = new URLSearchParams(window.location.search);
            let debugHtml = '';
            if (urlParams.get('debug') === 'true') {
                debugHtml = `
                    <div class="alert alert-info mb-3">
                        <strong>Long Paragraph Debug:</strong><br>
                        Parts: ${parts.length}<br>
                        Word Bank: ${JSON.stringify(shuffledWordBank)}<br>
                        Correct Answers: ${JSON.stringify(correctAnswers)}<br>
                    </div>
                `;
            }
            
            // Combine everything into the container
            container.appendChild(paragraphContainer);
            container.appendChild(wordBankSection);
            container.innerHTML += hiddenInputsHtml + debugHtml;
            
            return container;
        }

        async function submitAssessment(submissionData) {
            try {
                showLoader();
                
                // Get assessment ID from URL
                const urlParams = new URLSearchParams(window.location.search);
                const assessmentId = urlParams.get('id');
                
                if (!assessmentId) {
                    throw new Error('No assessment ID provided');
                }
                
                // Prepare submission data
                const data = {
                    answers: submissionData ? submissionData.answers : userAnswers,
                    score: submissionData ? submissionData.score : null
                };
                
                console.log('Submitting data:', data);
                
                const response = await fetch(`/api/assessments/${assessmentId}/submit`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(data)
                });
                
                if (!response.ok) {
                    throw new Error('Failed to submit assessment');
                }
                
                const result = await response.json();
                
                if (result.success) {
                    // Show success message
                    document.getElementById('assessmentContainer').innerHTML = `
                        <div class="alert alert-success">
                            <h4 class="alert-heading">Assessment Submitted Successfully!</h4>
                            <p>Your score: ${data.score !== null ? data.score + '%' : 'Will be graded by your teacher'}</p>
                            <hr>
                            <p class="mb-0">You can now return to your assessments page or review your work.</p>
                        </div>
                        <div class="d-flex gap-2">
                            <a href="/student/assessments" class="btn btn-primary">
                                <i class="bi bi-arrow-left"></i> Back to Assessments
                            </a>
                            <button onclick="window.location.reload()" class="btn btn-outline-secondary">
                                <i class="bi bi-arrow-clockwise"></i> Review Your Work
                            </button>
                        </div>
                    `;
                } else {
                    throw new Error(result.error || 'Unknown error submitting assessment');
                }
            } catch (error) {
                console.error('Error submitting assessment:', error);
                alert(`Error submitting assessment: ${error.message}`);
            } finally {
                hideLoader();
            }
        }
    </script>
    <!-- Direct fix for drag and drop functionality -->
    <script>
        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Applying drag-drop fixes...');
            
            // Fix for existing drop targets
            const dropTargets = document.querySelectorAll('.drop-target, [id^="target-"]');
            console.log('Found drop targets:', dropTargets.length);
            
            dropTargets.forEach(target => {
                // Apply styling
                target.style.display = 'inline-block';
                target.style.minWidth = '120px';
                target.style.height = '35px';
                target.style.border = '2px dashed #ced4da';
                target.style.borderRadius = '4px';
                target.style.margin = '0 5px';
                target.style.verticalAlign = 'middle';
                target.style.backgroundColor = '#f8f9fa';
                
                // Add event listeners
                target.ondragover = function(e) {
                    e.preventDefault();
                    this.classList.add('highlight');
                };
                
                target.ondragleave = function() {
                    this.classList.remove('highlight');
                };
                
                target.ondrop = function(e) {
                    e.preventDefault();
                    this.classList.remove('highlight');
                    
                    const id = e.dataTransfer.getData('text');
                    const draggedItem = document.getElementById(id);
                    
                    if (draggedItem) {
                        // Clear any existing content
                        this.innerHTML = '';
                        // Add the dragged text content
                        this.textContent = draggedItem.textContent;
                        // Apply filled styling
                        this.classList.add('filled');
                        this.style.borderStyle = 'solid';
                        this.style.borderColor = '#6c757d';
                        this.style.backgroundColor = '#e9ecef';
                        this.style.textAlign = 'center';
                        this.style.lineHeight = '35px';
                        this.style.fontWeight = '500';
                        
                        // Hide the original item
                        draggedItem.style.display = 'none';
                        
                        // Update hidden form elements
                        const index = this.dataset.index || this.id.replace('target-', '');
                        const questionId = window.assessment && window.assessment.id ? window.assessment.id : 'question';
                        
                        const meaningInput = document.querySelector(`input[name="meaning_question_${questionId}_${index}"]`);
                        if (meaningInput) {
                            meaningInput.value = draggedItem.textContent;
                            meaningInput.removeAttribute('required');
                        }
                        
                        // Store answer for submission
                        if (!window.userAnswers) window.userAnswers = [];
                        if (!window.userAnswers[0]) window.userAnswers[0] = {};
                        if (!window.userAnswers[0].dropTargets) window.userAnswers[0].dropTargets = {};
                        window.userAnswers[0].dropTargets[index] = {
                            text: draggedItem.textContent,
                            correct: draggedItem.textContent === this.dataset.correctAnswer
                        };
                    }
                };
            });
            
            // Fix for draggable items
            const draggableItems = document.querySelectorAll('.draggable-item');
            console.log('Found draggable items:', draggableItems.length);
            
            draggableItems.forEach((item, index) => {
                // Set ID if not already set
                if (!item.id) {
                    item.id = `draggable-${index}`;
                }
                
                // Apply styling
                item.style.padding = '8px 12px';
                item.style.margin = '5px';
                item.style.backgroundColor = '#e7f3ff';
                item.style.border = '1px solid #b8daff';
                item.style.borderRadius = '4px';
                item.style.cursor = 'grab';
                item.style.display = 'inline-block';
                
                // Make draggable
                item.draggable = true;
                
                // Add event listeners
                item.ondragstart = function(e) {
                    e.dataTransfer.setData('text', this.id);
                    this.classList.add('dragging');
                    this.style.opacity = '0.5';
                };
                
                item.ondragend = function() {
                    this.classList.remove('dragging');
                    this.style.opacity = '1';
                };
            });
        });
    </script>
    <!-- Emergency fix for drag and drop exercise -->
    <script>
        // Wait for DOM to be fully loaded and assessment data to be available
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up emergency fix and monitoring');
            
            // Set up a MutationObserver to watch for the container being added to the DOM
            const bodyObserver = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1) { // Element node
                                if (node.id === 'dragDropContainer') {
                                    console.log('MutationObserver: dragDropContainer added to DOM');
                                    setTimeout(attemptFix, 100); // Try fix when container is detected
                                } else if (node.querySelector && node.querySelector('#dragDropContainer')) {
                                    console.log('MutationObserver: Container with dragDropContainer inside added');
                                    setTimeout(attemptFix, 100); // Try fix when container is detected
                                }
                            }
                        });
                    }
                });
            });
            
            // Start observing
            bodyObserver.observe(document.body, { childList: true, subtree: true });
            
            // Check if container exists immediately
            const initialCheck = document.getElementById('dragDropContainer');
            console.log('Initial container check:', initialCheck ? 'exists' : 'does not exist');
            
            // Instead of a single timeout, let's use a retry mechanism
            let retryCount = 0;
            const maxRetries = 10; // Increase max retries
            
            // Define the fix function
            function attemptFix() {
                console.log(`Emergency fix: Attempt ${retryCount+1} to rebuild drag-and-drop exercise`);
                
                // Check if assessment data is available
                console.log('Assessment data available:', !!window.assessment);
                
                if (!window.assessment) {
                    console.warn('Assessment data not available yet, retrying...');
                    if (retryCount < maxRetries) {
                        retryCount++;
                        // Exponential backoff to retry
                        setTimeout(attemptFix, 500 * retryCount); // Use shorter initial timeout
                    } else {
                        console.error('Failed to get assessment data after multiple attempts');
                        // Create a visible error message in the container
                        const container = document.getElementById('dragDropContainer');
                        if (container) {
                            container.innerHTML = `
                                <div class="alert alert-danger">
                                    <strong>Error:</strong> Could not load the drag-and-drop exercise. 
                                    Please try refreshing the page.
                                </div>
                            `;
                        }
                    }
                    return;
                }
                
                // Check if this is a drag-and-drop assessment
                console.log('Assessment type:', window.assessment.type);
                if (window.assessment.type !== 'drag-and-drop') {
                    console.log('Not a drag-and-drop assessment, skipping fix');
                    return;
                }

                // Get the drag and drop container - use the new structure
                const dragDropContainer = document.getElementById('dragDropContainer');
                
                if (!dragDropContainer) {
                    console.log('Container not found yet, will retry');
                    if (retryCount < maxRetries) {
                        retryCount++;
                        setTimeout(attemptFix, 300 * retryCount);
                    }
                    return;
                }
                
                // Check if we have questions data correctly
                if (!window.assessment.questions || !window.assessment.questions.length) {
                    // Try to detect questions from other properties if possible
                    if (window.assessment.wordBank && window.assessment.answers) {
                        console.log('No questions array but found wordBank and answers, creating question structure');
                        window.assessment.questions = [{
                            type: 'drag-and-drop',
                            subtype: 'long-paragraph-fill-in-blank', 
                            text: window.assessment.text || '',
                            wordBank: window.assessment.wordBank || [],
                            answers: window.assessment.answers || [],
                            extraWords: window.assessment.extraWords || []
                        }];
                    }
                }
                
                // Container exists, check if it's empty or just has loading spinner
                if (container.children.length === 0 || 
                    (container.children.length === 1 && container.firstChild.className === 'text-center')) {
                    console.log('Container is empty or just has loading spinner, applying real fix');
                    
                    // Determine the question subtype
                    let subtype = '';
                    if (window.assessment.subtype) {
                        subtype = window.assessment.subtype;
                    } else if (window.assessment.questions && window.assessment.questions.length > 0) {
                        subtype = window.assessment.questions[0].subtype;
                    }
                    
                    if (subtype === 'long-paragraph-fill-in-blank' || !subtype) {
                        console.log('Emergency fix: Rendering drag-and-drop properly');
                        try {
                            // Call the main rendering function
                            if (typeof renderDragAndDropAssessment === 'function') {
                                renderDragAndDropAssessment(container);
                            } else {
                                // If the function doesn't exist yet, try again later
                                setTimeout(attemptFix, 500);
                            }
                        } catch (err) {
                            console.error('Error rendering drag and drop:', err);
                        }
                    }
                }
            }
            
            // Make it globally accessible
            window.attemptFix = attemptFix;
            
            // Try to apply the fix immediately
            attemptFix();
            
            // Also listen for the assessment-loaded event
            document.addEventListener('assessment-loaded', function(e) {
                console.log('assessment-loaded event detected, applying fix');
                // Update window.assessment if not already set
                if (!window.assessment) {
                    window.assessment = e.detail;
                    console.log('Updated window.assessment from event');
                }
                // Wait a moment to ensure containers are in the DOM
                setTimeout(attemptFix, 200);
            });
            
            // One final safety check - try again after a few seconds
            setTimeout(attemptFix, 2000);
        });
    </script>
</body>
</html> 